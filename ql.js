// Generated by CoffeeScript 1.9.1
var _, builtin, builtinsources, fn, fn1, fn2, fn3, fn4, i, len, name, opssource, optype, ql, ref, ref1, ref2, ref3, transformops, type,
  slice = [].slice;

transformops = require('./ops/transform');

builtinsources = [require('./ops/boolean'), require('./ops/conditional'), require('./ops/maths'), require('./ops/transform')];

builtin = {
  params: {},
  unary: {},
  binary: {},
  trinary: {}
};

for (i = 0, len = builtinsources.length; i < len; i++) {
  opssource = builtinsources[i];
  for (type in opssource) {
    optype = opssource[type];
    for (name in optype) {
      fn = optype[name];
      builtin[type][name] = fn;
    }
  }
}

ql = function(_query, def) {
  var _, fn1, fn2, fn3, fn4, fn5, ref, ref1, ref2, ref3, res;
  res = {
    query: function() {
      return _query;
    },
    fresh: function() {
      _query.__fresh = true;
      return res;
    },
    clone: function() {
      return ql(_query, def);
    }
  };
  fn1 = function(fn) {
    return res[name] = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      _query = fn.apply(null, [_query].concat(slice.call(args)));
      return res;
    };
  };
  for (name in def) {
    fn = def[name];
    fn1(fn);
  }
  ref = transformops.params;
  fn2 = function(name) {
    return res[name] = function(params) {
      _query = ql[name](params, _query);
      return res;
    };
  };
  for (name in ref) {
    _ = ref[name];
    fn2(name);
  }
  ref1 = transformops.unary;
  fn3 = function(name) {
    return res[name] = function() {
      _query = ql[name](_query);
      return res;
    };
  };
  for (name in ref1) {
    _ = ref1[name];
    fn3(name);
  }
  ref2 = transformops.binary;
  fn4 = function(name) {
    return res[name] = function(right) {
      _query = ql[name](_query, right);
      return res;
    };
  };
  for (name in ref2) {
    _ = ref2[name];
    fn4(name);
  }
  ref3 = transformops.trinary;
  fn5 = function(name) {
    return res[name] = function(left, right) {
      _query = ql[name](_query, left, right);
      return res;
    };
  };
  for (name in ref3) {
    _ = ref3[name];
    fn5(name);
  }
  return res;
};

ql.use = function(def) {
  var extra, res;
  extra = {};
  res = function(query) {
    return ql(query, def);
  };
  for (name in ql) {
    fn = ql[name];
    res[name] = fn;
  }
  res.use = function(def) {
    for (name in def) {
      fn = def[name];
      extra[name] = fn;
    }
    return res;
  };
  return res.use(def);
};

ref = builtin.params;
fn1 = function(name) {
  return ql[name] = function(params, source) {
    return {
      __query: name,
      __params: params,
      __source: source
    };
  };
};
for (name in ref) {
  _ = ref[name];
  fn1(name);
}

ref1 = builtin.unary;
fn2 = function(name) {
  return ql[name] = function(source) {
    return {
      __query: name,
      __source: source
    };
  };
};
for (name in ref1) {
  _ = ref1[name];
  fn2(name);
}

ref2 = builtin.binary;
fn3 = function(name) {
  return ql[name] = function(left, right) {
    return {
      __query: name,
      __left: left,
      __right: right
    };
  };
};
for (name in ref2) {
  _ = ref2[name];
  fn3(name);
}

ref3 = builtin.trinary;
fn4 = function(name) {
  return ql[name] = function(params, left, right) {
    return {
      __query: name,
      __params: params,
      __left: left,
      __right: right
    };
  };
};
for (name in ref3) {
  _ = ref3[name];
  fn4(name);
}

ql.desc = require('./ql/desc');

ql.merge = require('./ql/merge');

ql.split = require('./ql/split');

ql.diff = require('./ql/diff');

ql.build = require('./ql/build');

ql.exec = require('./ql/exec');

module.exports = ql;
